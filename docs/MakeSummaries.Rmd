---
title: "Make GO Summaries"
author: "Steve Pederson"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
					  warning = FALSE, message = FALSE)
```

## Introduction

```{r loadPackages}
library(GO.db)
library(graph)
library(dnet)
library(magrittr)
library(tidyverse)
library(pander)
library(scales)
library(plotly)
```

The aim of this page is to keep an up-to-date summary of the Gene Ontology database, as represented in the R package `GO.db`.
The information contained for each GO term is:

- Which Ontology the GO term belongs to
- The *shortest path* back to the root node of the relevant ontology
- The *longest path* back to the root node of the relevant ontology
- Whether the GO term is a *terminal node* (i.e. it has no children)

The main object created is available [here](../data/goSummaries.RDS) and this will load as a `tibble`.

## Create the Basic Graphs

The package `AnnotationDbi` contains the function `makeGOGraph` which returns a `graphNEL` graph.
In the following, we will:

1. Create a graph for each ontology and remove the node `"all"` as this is essentially redundant
2. Reverse the direction of the DAG for compatibility with tools in the package [`dnet`](https://cran.r-project.org/web/packages/dnet/index.html). Whilst hosted on CRAN, this package Depends on the bioconductor package [`supraHex`](https://www.bioconductor.org/packages/release/bioc/html/supraHex.html) and should be installed using `BiocManager::install("dnet")`

Note that the following code can take several minutes to run as these are large graphs.

```{r makeGraphs, cache=TRUE}
graphs <- c(BP = "bp", CC = "cc", MF = "mf") %>%
	lapply(makeGOGraph) %>%
	lapply(function(x){removeNode("all", x)}) %>%
	lapply(dDAGreverse)
```

```{r summariseGraphs, echo=FALSE}
tibble(Ontology = names(graphs),
	   Nodes = vapply(graphs, numNodes, integer(1)),
	   Edges = vapply(graphs, function(x){
	   	length(unlist(edgeL(x)))
	   }, integer(1))) %>%
	pander(caption = "Summary of graph sizes for each ontology",
		   big.mark = ",")
```


## Find the Key Information

```{r goSummaries}
goSummaries <- lapply(graphs, function(x){
	lng <- dDAGlevel(x, "longest_path") - 1
	shrt <- dDAGlevel(x, "shortest_path") - 1
	tips <- dDAGtip(x)
	tibble(
		id = unique(c(names(lng), names(shrt))),
		shortest_path = shrt,
		longest_path = lng,
		terminal_node = id %in% tips
		)
}) %>%
	bind_rows() %>%
	mutate(ontology = Ontology(id))
```

```{r summarisePaths, echo=FALSE, fig.cap = "Path lengths for each ontology, based on whether a term is a terminal node or not."}
goSummaries %>%
	gather(key = "type", value = "path", contains("path")) %>%
	ggplot(aes(terminal_node, path, fill = type)) +
	geom_boxplot() +
	facet_grid(type~ontology, scales = "free") +
	labs(y = "Path Length") +
	theme_bw()
```

```{r cumulativeTerms, echo=FALSE, fig.cap = "Cumulative number of GO Terms with paths $\\geq$ x."}
goSummaries %>%
	gather(key = "type", value = "path", contains("path")) %>%
	arrange(path) %>%
	group_by(ontology, type, path) %>%
	tally() %>%
	mutate(n = cumsum(n)) %>%
	ggplot(aes(path, n, colour = ontology, linetype = type)) +
	geom_line() +
	labs(x = "Path Length",
		 y = "Cumulative Number of GO Terms") +
	scale_y_continuous(labels = comma) +
	theme_bw()
```

## Examples

In reality, we can just add this table to our GO analysis table from tools like `goana()` and use it to filter results before adjusting p-values.

As an example of thow to use this to assist our decision making, if we chose to remove GO terms with a shortest path $\leq$ 4, we can see how many terms we would keep and retain.

```{r}
ggplotly(goSummaries %>%
	mutate(keep = shortest_path > 4) %>%
	ggplot(aes(keep, fill = terminal_node)) +
	geom_bar() +
	facet_wrap(~ontology, nrow = 1) +
	scale_y_continuous(labels = comma) +
	labs(x = "Term Retained", y = "Total") +
	theme_bw())
```

```{r}
goSummaries %>%
	mutate(keep = shortest_path > 4) %>%
	group_by(ontology, terminal_node, keep) %>%
	tally() %>%
	spread(key = keep, value = n) %>%
	rename(Discard = `FALSE`,
		   Retain = `TRUE`) %>%
	bind_rows(
		tibble(ontology = "**Total**",
			   Discard = sum(.$Discard),
			   Retain = sum(.$Retain))) %>%
	pander(big.mark = ",",
		   justify = "llrr")
```

Alternatively, we could remove GO terms with a longest path back to the root node is $\leq 5$ steps.

```{r}
ggplotly(goSummaries %>%
	mutate(keep = longest_path > 5) %>%
	ggplot(aes(keep, fill = terminal_node)) +
	geom_bar() +
	facet_wrap(~ontology, nrow = 1) +
	scale_y_continuous(labels = comma) +
	labs(x = "Term Retained", y = "Total") +
	theme_bw())
```

```{r}
goSummaries %>%
	mutate(keep = longest_path > 5) %>%
	group_by(ontology, terminal_node, keep) %>%
	tally() %>%
	spread(key = keep, value = n) %>%
	rename(Discard = `FALSE`,
		   Retain = `TRUE`) %>%
	bind_rows(
		tibble(ontology = "**Total**",
			   Discard = sum(.$Discard),
			   Retain = sum(.$Retain))) %>%
	pander(big.mark = ",",
		   justify = "llrr")
```



```{r, echo=FALSE}
write_rds(goSummaries, "../data/goSummaries.RDS")
```

The summaries obtained above can be downloaded from [here](../data/goSummaries.RDS).
Place this in the appropriate folder and the object can then be imported using `read_rds("path/to/goSummaries.RDS")`
